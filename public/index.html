<!DOCTYPE html>
<html>
<head>
    <title>Default Page!</title>
    <script type="text/javascript" src="jquery-1.9.1.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script type="text/javascript">
        /* Globals */
        var canvas, context;
        var WIDTH, HEIGHT;
        var localUpdateStream = [];
        var queuedLocalUpdateStream = [];
        var remoteUpdateStreams = {}, remoteMouseStreams = {};
        var canvasData = [];
        var numClients = 0;
        var myColor = 0;
        var isClick = false, isTouch = false, clickType=-1;
        var consoleMsg = ""

        /* Mouse enums */
        MouseButton = {
            NONE: -1,
            LEFT: 0,
            RIGHT: 2
        }


        socket = io.connect('http://169.229.100.33:3000');
        socket.on('initializeCanvas', function (data) {
            /* Initialize globals */
            WIDTH = data.width//window.innerWidth;
            HEIGHT = data.height//window.innerHeight;
            myColor = data.color;
            localUpdateStream = [];
            queuedLocalUpdateStream = [];
            remoteUpdateStreams = {};
            canvasData = [];

            /* Initialize and set up canvas based on parameters passed from the server */
            canvas = document.getElementById('canvas');
            context = canvas.getContext('2d');
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            $("#canvas").css("left",($(document).width() - WIDTH)/2 + "px");
            $("#canvas").css("top",($(document).height() - HEIGHT)/2 + "px");
            $("#canvas").css("border", "thin black solid");
            $("#canvas").css("position", "absolute");
            main();
        });

        socket.on('updateRemoteStream',function(data){
            if(!remoteUpdateStreams[data.sender]){
                remoteUpdateStreams[data.sender] = [];
            }
            for(var i=0,ii=data.data.length;i<ii;i++){
                remoteUpdateStreams[data.sender].push(data.data[i]);
            }
        });

        socket.on('updateMouseStream',function(data){
            remoteMouseStreams[data.sender] = [data.mousePos,data.color];
        });

        socket.on('endRemoteStream',function(data){
           console.log(remoteUpdateStreams[data.sender]);
           canvasData.push(remoteUpdateStreams[data.sender]);
           remoteUpdateStreams[data.sender]=[];
        })

        socket.on('updateClientList',function(data){
            numClients = data.numClients;
        });

        socket.on('updateCanvas',function(data){
            canvasData = data;
        })

        socket.on('clear',function(){
            localUpdateStream = [];
            queuedLocalUpdateStream = [];
            remoteUpdateStreams = {};
            canvasData = [];
        });

        socket.on('pause',function(data){
            console.log("paused");
            pause(data);
        })

        /**
         * Provides requestAnimationFrame in a cross browser way.
         */
        window.requestAnimFrame = (function() {
            return  window.requestAnimationFrame ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.oRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
                    function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
                        return  window.setTimeout(callback, 1000/60);
                    };
        })();

        /**
         * Provides cancelAnimationFrame in a cross browser way.
         */
        window.cancelAnimFrame = (function() {
            return  window.cancelAnimationFrame ||
                    window.webkitCancelAnimationFrame ||
                    window.mozCancelAnimationFrame ||
                    window.oCancelAnimationFrame ||
                    window.msCancelAnimationFrame ||
                    window.clearTimeout;
        })();

        function main(){
            /* Touch specific controls */
            canvas.addEventListener('touchmove',onTouchMove);
            canvas.addEventListener('touchstart',function(e){
                isClick=true;
                onTouchMove(event);
            });
            canvas.addEventListener('touchend',function(e){
                isClick=false;
            });

            /* General controls */
            $('#canvas').mousedown(function(event){
                /* Disable text drag icon */
                event.preventDefault();
                isClick = true;
                clickType = event.button;
                onMove(event);
            });
            $('#canvas').mouseup(function(event){
                isClick = false;
                clickType = MouseButton.NONE;
            });

            $('#canvas').mouseleave(function(event){
                socket.emit('updateMouseStream',{mousePos:[]});
            });
            $('#canvas').mousemove(onMove)

            /* Disable context menu */
            $('#canvas').on('contextmenu',function(e){return false});
            window.requestAnimFrame(drawLoop);
        }

        var onMove = function(event){
            if((event.pageX > canvas.offsetLeft && event.pageX < canvas.offsetLeft+WIDTH) && (event.pageY > canvas.offsetTop && event.pageY < canvas.offsetTop+HEIGHT)){
                var mouseX = event.pageX - canvas.offsetLeft;
                var mouseY = event.pageY - canvas.offsetTop;
                var index = mouseX+mouseY*WIDTH;
                socket.emit('updateMouseStream',{mousePos:[mouseX,mouseY]});
                /* Normal draw on MouseButton.LEFT
                 * Eraser on MouseButton.RIGHT
                 */
                if(clickType==MouseButton.LEFT){
                    localUpdateStream.push({pos:index,color:myColor});
                    queuedLocalUpdateStream.push({pos:index,color:myColor});
                }else if(clickType==MouseButton.RIGHT){
                }
            }
        }

        var onTouchMove = function(event){
            var mouseX = event.targetTouches[0].pageX - canvas.offsetLeft;
            var mouseY = event.targetTouches[0].pageY - canvas.offsetTop;
            event.preventDefault();
            var index = mouseX+mouseY*WIDTH;
            localUpdateStream.push({pos:index,color:myColor});
            queuedLocalUpdateStream.push({pos:index,color:myColor});
        }


        function drawLoop(){

            /* Emit new updates to server and add new updates to local data struct */
            handleCanvasUpdates();

            /* Clear canvas */
            context.fillStyle="#FFFFFF";
            context.fillRect(0,0,WIDTH,HEIGHT);
            context.fillStyle="#000000";
            context.fillText("Currently drawing: "+numClients,10,10);
            context.fillText("Console: "+consoleMsg,10,20);

            drawUserInputs(canvasData);
            drawUserInputs(localUpdateStream);
            for(var stream in remoteUpdateStreams){drawUserInputs(remoteUpdateStreams[stream]);}
            for(var stream in remoteMouseStreams){drawUserCursor(remoteMouseStreams[stream]);}
            window.requestAnimFrame(drawLoop);
        }

        function handleCanvasUpdates(){
            if(isClick){
                socket.emit("updateCanvasStream",{stream:queuedLocalUpdateStream});
            }else if(localUpdateStream.length>0){
                socket.emit("endCanvasStream");
                updateCanvasFromLocal(localUpdateStream);
                localUpdateStream = [];
            }
            queuedLocalUpdateStream = [];
        }

        function updateCanvasFromLocal(data){
            canvasData.push(data);
        }

        /* Draw functions
         * Draws lines contained in an array
         * Expects objects in array to have properties "pos" and "color"
         */
        function drawUserInputs(inputData){
            /* Update drawing */
            context.lineWidth=1;
            var currPixel,currColor,prevPos = [];
            for(var i=0;i<inputData.length;i++){
                if($.isArray(inputData[i])){
                    drawUserInputs(inputData[i]);
                    prevPos=[];
                }else if(inputData[i].pos){
                    currPixel = inputData[i].pos;
                    currColor = inputData[i].color;
                    var yPos = parseInt(currPixel/WIDTH);
                    var xPos = currPixel - (yPos*WIDTH);

                    /* Set the color (required) */
                    context.strokeStyle = colorToStyleString(currColor);
                    /* Set line width (optional) */
                    if(inputData[i].thickness){
                        context.lineWidth = inputData[i].thickness;
                    }else{
                        context.lineWidth = 1;
                    }

                    /* Draw the line */
                    if(prevPos){
                        drawLine(prevPos[0],prevPos[1],xPos,yPos);
                        //context.fillRect(xPos,yPos,xPos-prevPos[0],yPos-prevPos[1]);
                    }

                    prevPos = [xPos,yPos];
                }
            }
        }

        function drawUserCursor(mouseInfo){
            if(mouseInfo){
                var mousePos = mouseInfo[0];
                var mouseColor = mouseInfo[1];
                context.fillStyle = colorToStyleString(mouseColor);
                context.fillRect(mousePos[0]-5,mousePos[1]-5,10,10);
            }
        }

        function drawLine(x1, y1, x2, y2){
            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.closePath();
            context.stroke();
        }

        function pause(message){
            context.fillText("Paused",WIDTH/2,HEIGHT/2);
            context.fillText(message,WIDTH/2,HEIGHT/2+10);
            alert(message);
        }

        /* Given an array, returns the array if it contains data.
         * Else, returns a false boolean
         */
        function notEmpty(someArray){
            if(someArray.length>0){
                return someArray;
            }else{
                return false;
            }
        }

    function colorToStyleString(color){
        if(color.length==4){
            return "rgba("+color[0]+","+color[1]+","+color[2]+","+color[3]+")";
        }else if(color.length==3){
            return "rgb("+color[0]+","+color[1]+","+color[2]+")";
        }else{
            throw new TypeError(color+"must be of length 3 or 4 and contain color information");
        }
    }

    </script>
<link rel="stylesheet" type="text/css" href="index.css" />
</head>
<body>
<canvas id="canvas"></canvas>
</body>
</html>